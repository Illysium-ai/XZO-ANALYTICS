-- Snowflake SQL UDTF for get_depletions_forecast
-- Target Schema: APOLLO_WILLIAMGRANT.FORECAST

-- USE SCHEMA APOLLO_WILLIAMGRANT.FORECAST;


-- Snowflake SQL User-Defined Table Function (UDTF) for get_depletions_forecast (FINAL CORRECTED VERSION)
-- Fixes both the bind variable error and the ARRAY_CONTAINS type mismatch error.

CREATE OR REPLACE FUNCTION FORECAST.UDTF_GET_DEPLETIONS_FORECAST(
    P_FORECAST_METHODS VARCHAR,
    P_MARKETS ARRAY,
    P_CUSTOMERS ARRAY,
    P_BRANDS ARRAY,
    P_VARIANTS ARRAY,
    P_VARIANT_SIZE_PACK_DESCS ARRAY
)
RETURNS TABLE (
    MARKET_ID VARCHAR,
    MARKET VARCHAR,
    MARKET_AREA_NAME VARCHAR,
    CUSTOMER_ID VARCHAR,
    CUSTOMER VARCHAR,
    BRAND VARCHAR,
    VARIANT VARCHAR,
    VARIANT_ID VARCHAR,
    VARIANT_SIZE_PACK_DESC VARCHAR,
    VARIANT_SIZE_PACK_ID VARCHAR,
    YEAR INTEGER,
    MONTH INTEGER,
    FORECAST_METHOD VARCHAR,
    FORECAST_GENERATION_MONTH_DATE DATE,
    DATA_TYPE VARCHAR,
    IS_MANUAL_INPUT BOOLEAN,
    FORECAST_STATUS VARCHAR,
    CURRENT_VERSION INTEGER,
    GROUP_ID INTEGER,
    PUBLICATION_ID INTEGER,
    TAG_ID ARRAY,
    TAG_NAME ARRAY,
    COMMENT VARCHAR,
    CASE_EQUIVALENT_VOLUME FLOAT,
    PY_CASE_EQUIVALENT_VOLUME FLOAT,
    CY_3M_CASE_EQUIVALENT_VOLUME FLOAT,
    CY_6M_CASE_EQUIVALENT_VOLUME FLOAT,
    CY_12M_CASE_EQUIVALENT_VOLUME FLOAT,
    PY_3M_CASE_EQUIVALENT_VOLUME FLOAT,
    PY_6M_CASE_EQUIVALENT_VOLUME FLOAT,
    PY_12M_CASE_EQUIVALENT_VOLUME FLOAT,
    PROJECTED_CASE_EQUIVALENT_VOLUME FLOAT,
    PREV_PUBLISHED_CASE_EQUIVALENT_VOLUME FLOAT,
    GSV_RATE FLOAT,
    GROSS_SALES_VALUE FLOAT,
    PY_GROSS_SALES_VALUE FLOAT
)
LANGUAGE SQL
AS
$$
WITH DRAFT_FILTERED AS (
    -- Stage 1: Filter the large analytical table first.
    SELECT f.*
    FROM FORECAST.VW_GET_DEPLETIONS_BASE AS f
    WHERE
        f.FORECAST_GENERATION_MONTH_DATE = FORECAST.UDF_GET_VALID_FORECAST_GENERATION_MONTH_DATE()
        AND (P_MARKETS IS NULL OR ARRAY_SIZE(P_MARKETS) = 0 OR ARRAY_CONTAINS(f.MARKET_ID::VARIANT, P_MARKETS))
        AND (P_FORECAST_METHODS IS NULL OR f.FORECAST_METHOD = P_FORECAST_METHODS)
        AND (P_CUSTOMERS IS NULL OR ARRAY_SIZE(P_CUSTOMERS) = 0 OR ARRAY_CONTAINS(f.CUSTOMER_ID::VARIANT, P_CUSTOMERS))
        AND (P_BRANDS IS NULL OR ARRAY_SIZE(P_BRANDS) = 0 OR ARRAY_CONTAINS(f.BRAND::VARIANT, P_BRANDS))
        AND (P_VARIANTS IS NULL OR ARRAY_SIZE(P_VARIANTS) = 0 OR ARRAY_CONTAINS(f.VARIANT::VARIANT, P_VARIANTS))
        AND (P_VARIANT_SIZE_PACK_DESCS IS NULL OR ARRAY_SIZE(P_VARIANT_SIZE_PACK_DESCS) = 0 OR ARRAY_CONTAINS(f.VARIANT_SIZE_PACK_DESC::VARIANT, P_VARIANT_SIZE_PACK_DESCS))
)
SELECT
    fd.MARKET_ID,
    fd.MARKET,
    fd.MARKET_AREA_NAME,
    fd.CUSTOMER_ID,
    fd.CUSTOMER,
    fd.BRAND,
    fd.VARIANT,
    fd.VARIANT_ID,
    fd.VARIANT_SIZE_PACK_DESC,
    fd.VARIANT_SIZE_PACK_ID,
    fd.YEAR,
    fd.MONTH,
    fd.FORECAST_METHOD,
    fd.FORECAST_GENERATION_MONTH_DATE,
    fd.DATA_TYPE,
    (CASE WHEN fd.SOURCE_TABLE = 'manual' THEN TRUE
          WHEN fd.MANUAL_CASE_EQUIVALENT_VOLUME IS NOT NULL THEN TRUE ELSE FALSE
     END) AS IS_MANUAL_INPUT,
    COALESCE(fd.PUBLICATION_STATUS, fd.MANUAL_FORECAST_STATUS, fd.BASE_FORECAST_STATUS)::VARCHAR AS FORECAST_STATUS,
    COALESCE(fd.VERSION_NUMBER, fd.MANUAL_CURRENT_VERSION, 0) AS CURRENT_VERSION,
    fd.GROUP_ID,
    fd.PUBLICATION_ID,
    fd.TAG_IDS AS TAG_ID,
    fd.TAG_NAMES AS TAG_NAME,
    MAX(fd.COMMENT) AS COMMENT,
    ROUND(SUM(COALESCE(fd.MANUAL_CASE_EQUIVALENT_VOLUME, fd.BASE_CASE_EQUIVALENT_VOLUME)), 2) AS CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.PY_CASE_EQUIVALENT_VOLUME,0)), 2) AS PY_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.CY_3M_CASE_EQUIVALENT_VOLUME, 0)), 2) AS CY_3M_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.CY_6M_CASE_EQUIVALENT_VOLUME, 0)), 2) AS CY_6M_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.CY_12M_CASE_EQUIVALENT_VOLUME, 0)), 2) AS CY_12M_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.PY_3M_CASE_EQUIVALENT_VOLUME, 0)), 2) AS PY_3M_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.PY_6M_CASE_EQUIVALENT_VOLUME, 0)), 2) AS PY_6M_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.PY_12M_CASE_EQUIVALENT_VOLUME, 0)), 2) AS PY_12M_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.PROJECTED_CASE_EQUIVALENT_QUANTITY, 0)), 2) AS PROJECTED_CASE_EQUIVALENT_VOLUME,
    ROUND(SUM(COALESCE(fd.PREV_PUBLISHED_CASE_EQUIVALENT_VOLUME, 0)), 2) AS PREV_PUBLISHED_CASE_EQUIVALENT_VOLUME,
    ANY_VALUE(fd.GSV_RATE) as GSV_RATE,
    ROUND(SUM(COALESCE(fd.MANUAL_CASE_EQUIVALENT_VOLUME, fd.BASE_CASE_EQUIVALENT_VOLUME) * fd.GSV_RATE), 2) AS GROSS_SALES_VALUE,
    ROUND(SUM(COALESCE(fd.PY_CASE_EQUIVALENT_VOLUME, 0) * fd.GSV_RATE), 2) AS PY_GROSS_SALES_VALUE
FROM DRAFT_FILTERED fd
WHERE
    (P_FORECAST_METHODS IS NOT NULL OR fd.IS_PRIMARY_FORECAST_METHOD = 1)
GROUP BY
    fd.MARKET_ID, fd.MARKET, fd.MARKET_AREA_NAME, fd.CUSTOMER_ID, fd.CUSTOMER,
    fd.BRAND, fd.VARIANT, fd.VARIANT_ID, fd.VARIANT_SIZE_PACK_DESC, fd.VARIANT_SIZE_PACK_ID,
    fd.YEAR, fd.MONTH, fd.FORECAST_METHOD, fd.FORECAST_GENERATION_MONTH_DATE,
    fd.DATA_TYPE, IS_MANUAL_INPUT, FORECAST_STATUS, CURRENT_VERSION,
    fd.GROUP_ID, fd.PUBLICATION_ID, fd.TAG_IDS, fd.TAG_NAMES
ORDER BY
    fd.MARKET,
    fd.CUSTOMER,
    fd.VARIANT_SIZE_PACK_DESC,
    fd.YEAR,
    fd.MONTH
$$;

COMMENT ON FUNCTION FORECAST.UDTF_GET_DEPLETIONS_FORECAST(VARCHAR, ARRAY, ARRAY, ARRAY, ARRAY, ARRAY) IS
'Get filtered depletions forecast data for the valid forecast generation month.
It uses UDF_GET_VALID_FORECAST_GENERATION_MONTH_DATE() to determine the appropriate month.
Parameters:
  - P_FORECAST_METHODS: VARCHAR value of the forecast method to include (NULL = all)
  - P_MARKETS: ARRAY of market codes to include (NULL = all)
  - P_CUSTOMERS: ARRAY of customer_ids (first 5 of distributor_id) to include (NULL = all)
  - P_BRANDS: ARRAY of brand names to include (NULL = all)
  - P_VARIANTS: ARRAY of variant names to include (NULL = all)
  - P_VARIANT_SIZE_PACK_DESCS: ARRAY of variant size pack descriptions to include (NULL = all)
Depends on UDF: FORECAST.UDF_GET_VALID_FORECAST_GENERATION_MONTH_DATE().';